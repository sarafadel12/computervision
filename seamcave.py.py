# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19ilmi5OuwJsatMW8Arxvvq9WA0IWX6FP
"""

import sys

import numpy as np
from imageio.v2 import imread, imwrite
from scipy.ndimage import convolve
from tqdm import trange

def calc_energy(img):
    filter_du = np.array([
        [1.0, 2.0, 1.0],
        [0.0, 0.0, 0.0],
        [-1.0, -2.0, -1.0],
    ])
    # This converts it from a 2D filter to a 3D filter, replicating the same
    # filter for each channel: R, G, B
    filter_du = np.stack([filter_du] * 3, axis=2)

    filter_dv = np.array([
        [1.0, 0.0, -1.0],
        [2.0, 0.0, -2.0],
        [1.0, 0.0, -1.0],
    ])
    # This converts it from a 2D filter to a 3D filter, replicating the same
    # filter for each channel: R, G, B
    filter_dv = np.stack([filter_dv] * 3, axis=2)

    img = img.astype('float32')
    convolved = np.absolute(convolve(img, filter_du)) + np.absolute(convolve(img, filter_dv))

    # We sum the energies in the red, green, and blue channels
    energy_map = convolved.sum(axis=2)

    return energy_map

def minimum_seam(img):
    r, c, _ = img.shape
    energy_map = calc_energy(img)

    M = energy_map.copy()
    backtrack = np.zeros_like(M, dtype=int)  # Or np.int32 / np.int64 if needed


    for i in range(1, r):
        for j in range(0, c):
            # Handle the left edge of the image, to ensure we don't index -1
            if j == 0:
                idx = np.argmin(M[i - 1, j:j + 2])
                backtrack[i, j] = idx + j
                min_energy = M[i - 1, idx + j]
            else:
                idx = np.argmin(M[i - 1, j - 1:j + 2])
                backtrack[i, j] = idx + j - 1
                min_energy = M[i - 1, idx + j - 1]

            M[i, j] += min_energy

    return M, backtrack

import numpy as np

def carve_column(img):
    r, c, _ = img.shape

    M, backtrack = minimum_seam(img)

    # Copy image to draw the seam
    img_with_seam = img.copy()

    # Find the position of the smallest element in the last row of M
    j = np.argmin(M[-1])

    for i in reversed(range(r)):
        # Mark the seam in red (255, 0, 0)
        img_with_seam[i, j] = [255, 0, 0]
        j = backtrack[i, j]  # Move to the previous seam position

    return img_with_seam  # This returns the image with the red seam drawn

def crop_c(img, scale_c):
    r, c, _ = img.shape
    new_c =int(scale_c * c)

    new_c = max(1, new_c)
    for i in trange(c - new_c): # use range if you don't want to use tqdm
        img = carve_column(img)

    return img

def main():

    in_filename = "/content/castle.jpg"
    out_filename = "/content/output.jpg"
    outwithseam="/content/outwithseam.jpg"

    img =imread(in_filename)
    out = crop_c(img, 0.5)
    imwrite(out_filename, out)
    img_with_seam = carve_column(img)

    imwrite(outwithseam, img_with_seam.astype("uint8"))
    print("Saved seam visualization at:", outwithseam)

if __name__ == '__main__':
    main()

def crop_r(img, scale_r):
    img = np.rot90(img, 1, (0, 1))
    img = crop_c(img, scale_r)
    img = np.rot90(img, 3, (0, 1))
    return img

def main():
    which_axis = 'r'  # 'r' for rows, 'c' for columns
    scale = 0.5
    inn = "/content/castle.jpg"
    outt = "/content/out.jpg"

    print("Reading input image...")
    img = imread(inn)
    print("Image shape before processing:", img.shape)

    print(f"Processing axis: {which_axis}")
    if which_axis == 'r':
        out = crop_r(img, scale)
    elif which_axis == 'c':
        out = crop_c(img, scale)
    else:
        print('Invalid axis! Use "r" or "c".', file=sys.stderr)
        return

    print("Image shape after processing:", out.shape)

    print("Saving output image...")
    imwrite(outt, out.astype("uint8"))

    if os.path.exists(outt):
        print("Output saved successfully at:", outt)
    else:
        print("Image saving failed!")

if __name__ == '__main__':
    main()

